# -*- coding: utf-8 -*-
"""Bootcamp: Imersão Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HD0aZbBxM5NNjzt_G3yUxocYVj7kcKnn

Aula 2 - Importação
"""

import pandas as pd
import plotly.express as px

df_principal = pd.read_excel("/content/imersão python.xlsx",sheet_name="Principal")
df_principal

df_total_acoes = pd.read_excel("/content/imersão python.xlsx",sheet_name="Total_de_acoes")
df_total_acoes

df_ticker = pd.read_excel("/content/imersão python.xlsx",sheet_name="Ticker")
df_ticker

df_chatgpt = pd.read_excel("/content/imersão python.xlsx",sheet_name="Chatgpt")
df_chatgpt

df_principal = df_principal [['Ativo','Data', 'Último (R$)','Var. Dia (%)']].copy()
df_principal

df_principal = df_principal.rename(columns={'Último (R$)':'valor_final','Var. Dia (%)':'var_dia_pct'}).copy()
df_principal

df_principal['Var_pct'] = df_principal['var_dia_pct'] / 100
df_principal['valor_inicial'] = df_principal['valor_final'] / (df_principal['Var_pct']+1)
df_principal

df_principal = df_principal.merge(df_total_acoes, left_on='Ativo', right_on='Código', how='left')
df_principal

df_principal.drop(columns=['Código'])
df_principal

df_principal['Variacao_rs'] = (df_principal['valor_final'] - df_principal['valor_inicial']) * df_principal['Qtde. Teórica']
df_principal

pd.options.display.float_format = '{:.2f}'.format
df_principal

df_principal['Qtde. Teórica'] = df_principal['Qtde. Teórica'].astype(int)
df_principal

df_principal = df_principal.rename(columns={'Qtde. Teórica':'Qtd_teorica'}).copy()
df_principal

df_principal['Resultado'] = df_principal['Variacao_rs'].apply(lambda x: 'Subiu' if x > 0 else ('Desceu' if x < 0 else 'Estável'))
df_principal

df_principal = df_principal.merge(df_ticker, left_on='Ativo', right_on='Ticker', how='left')
df_principal.drop(columns=['Ticker'])
df_principal

df_principal = df_principal.merge(df_chatgpt, left_on='Nome', right_on='Nome da Empresa', how='left')
df_principal.drop(columns=['Nome da Empresa'])
df_principal

df_principal = df_principal.rename(columns={'Idade (fundação ou início de operações)' : 'Idade'}).copy()
df_principal

df_principal = df_principal.rename(columns={'Idade' : 'Ano_de_fundacao'}).copy()
df_principal

df_principal['Cat_Idade'] = df_principal['Idade em Anos'].apply(lambda x: 'Mais de 100 anos' if x > 100 else ('Menos de 50 anos' if x < 50 else 'Entre 50 e 100'))
df_principal

maior = df_principal['Variacao_rs'].max()
menor = df_principal['Variacao_rs'].min()
media = df_principal['Variacao_rs'].mean()
media_subiu = df_principal[df_principal['Resultado'] == 'Subiu']['Variacao_rs'].mean()
media_desceu = df_principal[df_principal['Resultado'] == 'Desceu']['Variacao_rs'].mean()


print("Maior:", maior)
print("Menor:", menor)
print("Média:", media)
print("Média de quem subiu:", media_subiu)
print("Média de quem desceu:", media_desceu)

df_principal_subiu = df_principal[df_principal['Resultado'] == 'Subiu']
df_principal_subiu

df_analise_segmento = df_principal_subiu.groupby('Segmento')['Variacao_rs'].sum().reset_index()
df_analise_segmento

df_analise_saldo = df_principal.groupby('Resultado')['Variacao_rs'].sum().reset_index()
df_analise_saldo

fig = px.bar(df_analise_saldo, x = 'Resultado', y = 'Variacao_rs', text = 'Variacao_rs', title = 'Variação Reais por Resultado')
fig.update_traces(texttemplate='R$ %{text:,.2f}')
fig.show()

fig = px.pie(df_analise_segmento, values='Variacao_rs', names='Segmento', title='Variação Reais das empresas valorizadas por Segmento de atuação')
fig.show()

fig = px.bar(df_principal, x = 'Cat_Idade', y = 'Variacao_rs', text = 'Variacao_rs', title = 'Variação Reais por Faixe de existência da empresa')
fig.update_traces(texttemplate='R$ %{text:,.2f}')
fig.show()

!pip install mplfinance

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import mplfinance as mpf
import yfinance as yf
import plotly.graph_objects as go
from plotly.subplots import make_subplots

dados = yf.download('PETR4.SA',start='2023-01-01', end='2023-12-31')
dados

dados.columns = ['Abertura','Maximo','Minimo','Fechamento', 'Fech_Ajust', 'Volume']

dados  = dados.rename_axis('Data')
dados

dados['Fechamento'].plot(figsize=(10,6))
plt.title('Variação do preço por data',fontsize=16)
plt.legend(['Fechamento'])

df = dados.head(60).copy()

# Convertendo o índice em uma coluna de data
df['Data'] = df.index

# Convertendo as datas para o formato numérico de matplotlib
# Isso é necessário para que o Matplotlib possa plotar as datas corretamente no gráfico
df['Data'] = df['Data'].apply(mdates.date2num)

fig, ax = plt.subplots(figsize=(15,8))

width = 0.7

for i in range(len(df)):
    # Determinando a cor do candle
    # Se o preço de fechamento for maior que o de abertura, o candle é verde (a ação valorizou nesse dia).
    # Se for menor, o candle é vermelho (a ação desvalorizou).
    if df['Fechamento'].iloc[i] > df['Abertura'].iloc[i]:
        color = 'green'
    else:
        color = 'red'

    # Desenhando a linha vertical do candle (mecha)
    # Essa linha mostra os preços máximo (topo da linha) e mínimo (base da linha) do dia.
    # Usamos `ax.plot` para desenhar uma linha vertical.
    # [df['Data'].iloc[i], df['Data'].iloc[i]] define o ponto x da linha (a data), e [df['Mínimo'].iloc[i], df['Máximo'].iloc[i]] define a altura da linha.
    ax.plot([df['Data'].iloc[i], df['Data'].iloc[i]],
            [df['Minimo'].iloc[i], df['Maximo'].iloc[i]],
            color=color,
            linewidth=1)

    ax.add_patch(plt.Rectangle((df['Data'].iloc[i] - width/2, min(df['Abertura'].iloc[i], df['Fechamento'].iloc[i])),
                               width,
                               abs(df['Fechamento'].iloc[i] - df['Abertura'].iloc[i]),
                               facecolor=color))

df['MA7'] = df['Fechamento'].rolling(window=7).mean()
df['MA14'] = df['Fechamento'].rolling(window=14).mean()

# Plotando as médias móveis
ax.plot(df['Data'], df['MA7'], color='orange', label='Média Móvel 7 Dias')  # Média de 7 dias
ax.plot(df['Data'], df['MA14'], color='yellow', label='Média Móvel 14 Dias')  # Média de 14 dias
# Adicionando legendas para as médias móveis
ax.legend()

# Formatando o eixo x para mostrar as datas
# Configuramos o formato da data e a rotação para melhor legibilidade
ax.xaxis_date() #O método xaxis_date() é usado para dizer ao Matplotlib que as datas estão sendo usadas no eixo x
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.xticks(rotation=45)

# Adicionando título e rótulos para os eixos x e y
plt.title("Gráfico de Candlestick - PETR4.SA com matplotlib")
plt.xlabel("Data")
plt.ylabel("Preço")

# Adicionando uma grade para facilitar a visualização dos valores
plt.grid(True)

# Exibindo o gráfico
plt.show()

# Criando subplots
'''
"Primeiro, criamos uma figura que conterá nossos gráficos usando make_subplots.
Isso nos permite ter múltiplos gráficos em uma única visualização.
Aqui, teremos dois subplots: um para o gráfico de candlestick e outro para o volume de transações."

'''
fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                    vertical_spacing=0.1,
                    subplot_titles=('Candlesticks', 'Volume Transacionado'),
                    row_width=[0.2, 0.7])

'''
"No gráfico de candlestick, cada candle representa um dia de negociação,
mostrando o preço de abertura, fechamento, máximo e mínimo. Vamos adicionar este gráfico à nossa figura."
'''
# Adicionando o gráfico de candlestick
fig.add_trace(go.Candlestick(x=df.index,
                             open=df['Abertura'],
                             high=df['Maximo'],
                             low=df['Minimo'],
                             close=df['Fechamento'],
                             name='Candlestick'),
                             row=1, col=1)

# Adicionando as médias móveis
# Adicionamos também médias móveis ao mesmo subplot para análise de tendências
fig.add_trace(go.Scatter(x=df.index,
                         y=df['MA7'],
                         mode='lines',
                         name='MA7 - Média Móvel 7 Dias'),
                         row=1, col=1)

fig.add_trace(go.Scatter(x=df.index,
                         y=df['MA14'],
                         mode='lines',
                         name='MA14 - Média Móvel 14 Dias'),
                         row=1, col=1)

# Adicionando o gráfico de barras para o volume
# Em seguida, criamos um gráfico de barras para o volume de transações, que nos dá uma ideia da atividade de negociação naquele dia
fig.add_trace(go.Bar(x=df.index,
                     y=df['Volume'],
                     name='Volume'),
                     row=2, col=1)

# Atualizando layout
#Finalmente, configuramos o layout da figura, ajustando títulos, formatos de eixo e outras configurações para tornar o gráfico claro e legível.
fig.update_layout(yaxis_title='Preço',
                  xaxis_rangeslider_visible=False,  # Desativa o range slider
                  width=1100, height=600)

# Mostrando o gráfico
fig.show()

dados = yf.download('AAPL', start='2023-01-01', end='2023-12-31')

mpf.plot(dados.head(30), type='candle', figsize = (16,8), volume=True, mav=(7,14))

#Setando parâmetros iniciais
dados_apple = yf.download('AAPL', start='2023-01-01', end='2023-12-31')
dados_apple.columns = ['Abertura','Maximo','Minimo','Fechamento', 'Fech_Ajust', 'Volume']
dados_apple  = dados_apple.rename_axis('Data')
dados_apple

# Plotando o preço de fechamento
dados_apple['Fechamento'].plot(figsize=(10,6))
plt.title('Variação do preço por data',fontsize=16)
plt.legend(['Fechamento'])

# Selecionando apenas os primeiros 60 dias para o gráfico de candlestick
d_apple = dados_apple.head(60).copy()

# Convertendo o índice em uma coluna de data
d_apple['Data'] = d_apple.index
d_apple['Data'] = d_apple['Data'].apply(mdates.date2num)

fig, ax = plt.subplots(figsize=(15,8))

width = 0.7

for i in range(len(d_apple)):
    # Determinando a cor do candle
    # Se o preço de fechamento for maior que o de abertura, o candle é verde (a ação valorizou nesse dia).
    # Se for menor, o candle é vermelho (a ação desvalorizou).
    if d_apple['Fechamento'].iloc[i] > d_apple['Abertura'].iloc[i]:
        color = 'green'
    else:
        color = 'red'

    # Desenhando a linha vertical do candle (mecha)
    ax.plot([d_apple['Data'].iloc[i], d_apple['Data'].iloc[i]],
            [d_apple['Minimo'].iloc[i], d_apple['Maximo'].iloc[i]],
            color=color,
            linewidth=1)

    ax.add_patch(plt.Rectangle((d_apple['Data'].iloc[i] - width/2, min(d_apple['Abertura'].iloc[i], d_apple['Fechamento'].iloc[i])),
                               width,
                               abs(d_apple['Fechamento'].iloc[i] - d_apple['Abertura'].iloc[i]),
                               facecolor=color))

d_apple['MA7'] = d_apple['Fechamento'].rolling(window=7).mean()
d_apple['MA14'] = d_apple['Fechamento'].rolling(window=14).mean()

# Plotando as médias móveis
ax.plot(d_apple['Data'], d_apple['MA7'], color='orange', label='Média Móvel 7 Dias')  # Média de 7 dias
ax.plot(d_apple['Data'], d_apple['MA14'], color='yellow', label='Média Móvel 14 Dias')  # Média de 14 dias
# Adicionando legendas para as médias móveis
ax.legend()

# Formatando o eixo x para mostrar as datas
# Configuramos o formato da data e a rotação para melhor legibilidade
ax.xaxis_date() #O método xaxis_date() é usado para dizer ao Matplotlib que as datas estão sendo usadas no eixo x
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.xticks(rotation=45)

# Adicionando título e rótulos para os eixos x e y
plt.title("Gráfico de Candlestick - PETR4.SA com matplotlib")
plt.xlabel("Data")
plt.ylabel("Preço")

# Adicionando uma grade para facilitar a visualização dos valores
plt.grid(True)
plt.show()

"""**ÚLTIMA PARTE DA IMERSÃO**"""

import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from prophet import Prophet

# Baixar dados dos últimos quatro anos para uma ação específica
dados = yf.download("JNJ", start="2020-01-01",end="2023-12-31", progress=False)
dados = dados.reset_index()

# Divide os dados em: treino (até o final do primeiro semestre de 2023) e teste (segundo semestre de 2023)
dados_treino = dados[dados['Date'] < '2023-07-31']
dados_teste = dados[dados['Date'] >= '2023-07-31']

# Preparar os dados para o FBProphet
dados_prophet_treino = dados_treino[['Date', 'Close']].rename(columns={'Date': 'ds', 'Close': 'y'})

# Cria e treina o modelo
modelo = Prophet(weekly_seasonality=True, yearly_seasonality=True, daily_seasonality=False)

modelo.add_country_holidays(country_name='US')

modelo.fit(dados_prophet_treino)

# Criar datas futuras para previsão até o final de 2023
futuro = modelo.make_future_dataframe(periods=150)
previsao = modelo.predict(futuro)

# Plota os dados de treino, teste e previsões
plt.figure(figsize=(14, 8))
plt.plot(dados_treino['Date'], dados_treino['Close'], label='Dados de Treino', color='blue')
plt.plot(dados_teste['Date'], dados_teste['Close'], label='Dados Reais (Teste)', color='green')
plt.plot(previsao['ds'], previsao['yhat'], label='Previsão', color='orange', linestyle='--')

plt.axvline(dados_treino['Date'].max(), color='red', linestyle='--', label='Início da Previsão')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento')
plt.title('Previsão de Preço de Fechamento vs Dados Reais')
plt.legend()
plt.show()